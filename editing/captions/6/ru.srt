1
00:00:58,990000 --> 00:01:01,820000
Майкл, добро пожаловать на мой канал.

2
00:01:01,820000 --> 00:01:12,930000
сегодня мы поговорим о float и double и о том, как эти две основные абстракции и реализации влияют на жизнь других программистов.

3
00:01:12,990000 --> 00:01:15,010000
так что, пожалуйста, представьтесь.

4
00:01:15,750000 --> 00:01:16,400000
спасибо вам.

5
00:01:16,400000 --> 00:01:18,340000
мне очень приятно быть здесь.

6
00:01:18,340000 --> 00:01:20,170000
спасибо, что пригласили меня, Никита.

7
00:01:20,390000 --> 00:01:21,900000
меня зовут Майкл Овертон.

8
00:01:21,900000 --> 00:01:27,050000
я профессор компьютерных наук и математики в Нью-Йоркском университете в Нью-Йорке.

9
00:01:29,110000 --> 00:01:30,890000
я проработал там всю свою карьеру.

10
00:01:31,110000 --> 00:01:40,330000
и это не является моим основным интересом, но одним из моих интересов долгое время была арифметика с плавающей запятой, главным образом потому, что я увлекся этим, потому что

11
00:01:40,350000 --> 00:01:51,450000
я преподавал численные вычисления на факультете компьютерных наук, и мне было действительно интересно объяснить студентам гораздо больше о том, как работает компьютер. вычислительная техника работала вместо этого

12
00:01:51,950000 --> 00:01:59,800000
Типичная вещь на занятиях по численному анализу на математическом факультете - вы тратите около 15 минут на обсуждение этого, а затем говорите обо всех этих математических методах.

13
00:01:59,800000 --> 00:02:05,860000
но на самом деле детали вычислений очень интересны, особенно студентам, изучающим информатику.

14
00:02:05,860000 --> 00:02:16,290000
так что в итоге я начал писать заметки, а затем это превратилось в небольшую книгу, которую я написал и которая была опубликована для SIAM, Общества промышленной прикладной математики, в 2001 году.

15
00:02:18,030000 --> 00:02:21,340000
а потом я оставил эту книгу.

16
00:02:21,340000 --> 00:02:33,440000
я имею в виду, что я пользовался этой книгой в течение многих лет, но на самом деле не особо оглядывался на нее за последние 20 лет, пока недавно у меня не появилась возможность написать второе издание, потому что с 2001 года многое изменилось.

17
00:02:33,440000 --> 00:02:35,010000
да, этого вы еще не знаете.

18
00:02:35,830000 --> 00:02:37,860000
с 2001 года так много изменилось.

19
00:02:37,860000 --> 00:02:42,250000
основные принципы остались прежними, но технологии, конечно, полностью изменились.

20
00:02:42,270000 --> 00:02:51,210000
так что на самом деле я очень близок к завершению второго издания, которое будет опубликовано издательством SIAM, предположительно, в 2025 году.

21
00:02:51,550000 --> 00:02:53,490000
о, отличные новости.

22
00:02:53,710000 --> 00:02:58,890000
не могли бы вы, пожалуйста, немного объяснить аудитории, что именно изменилось?

23
00:03:02,150000 --> 00:03:08,130000
может быть, было бы лучше сначала объяснить, что произошло в 1985 году с первоначальным стандартом с плавающей запятой.

24
00:03:09,830000 --> 00:03:24,920000
если мы углубимся в историю, а затем вернемся к настоящему позже, если вы пройдете весь путь назад, то на самом деле плавающая точка была впервые разработана Конрадом Цузе во время Второй мировой войны. Вторая мировая война

25
00:03:24,920000 --> 00:03:26,010000
я в Германии.

26
00:03:26,910000 --> 00:03:32,860000
Он на самом деле построил компьютер с двоичной арифметикой с плавающей запятой.

27
00:03:32,860000 --> 00:03:33,980000
но он не был электронным.

28
00:03:33,980000 --> 00:03:35,450000
он был электромеханическим.

29
00:03:35,590000 --> 00:03:38,760000
а позже были разработаны первые электронные компьютеры.

30
00:03:38,760000 --> 00:03:47,930000
конечно, было много людей, которые участвовали во всем этом процессе после войны, особенно фон Нейман и Тьюринг.

31
00:03:48,350000 --> 00:03:58,170000
а затем различные компании, конечно же, начали создавать электронные компьютеры и продавать их, особенно IBM.

32
00:03:58,470000 --> 00:04:01,690000
существовало множество различных способов выполнения компьютерной арифметики.

33
00:04:02,150000 --> 00:04:16,460000
это было очень запутанно, потому что в те дни вы могли запустить программу, скажем, на Фортране, на одном компьютере, на компьютере IBM, и вы могли получить совсем другие результаты, чем если бы вы запустили ее на другом компьютере, потому что способ, которым она была запущена,

34
00:04:16,460000 --> 00:04:20,850000
арифметика, реализованная на компьютере, была совсем другой.

35
00:04:20,990000 --> 00:04:23,090000
было много людей, которые были обеспокоены этим.

36
00:04:24,550000 --> 00:04:33,900000
стандарт с плавающей запятой был наконец опубликован в 1985 году после примерно пяти лет работы.

37
00:04:33,900000 --> 00:04:37,020000
на самом деле это было вскоре после того, как я стал аспирантом.

38
00:04:37,020000 --> 00:04:50,890000
я в этом не участвовал, но некоторые из моих коллег и близких друзей участвовали, и особенно профессор Велвел Кахан из Беркли, который руководил всем процессом.

39
00:04:51,270000 --> 00:05:01,980000
Он также участвовал в разработке чипа с плавающей запятой для нового, на тот момент, Intel 8087, который был процессором с плавающей запятой. пойнт-чип.

40
00:05:01,980000 --> 00:05:09,610000
на самом деле это был сопроцессор с плавающей запятой, который работал вместе с процессором 8088, который они разрабатывали.

41
00:05:11,150000 --> 00:05:24,490000
и Кахан принимал активное участие в его разработке, и многие из тех же идей были приняты в Стандарте, который был опубликован в 1985 году IEEE, а затем также принят на международном уровне.

42
00:05:25,830000 --> 00:05:41,170000
так вот, случилось так, что Стандарт оказал огромное влияние, потому что в то время существовали различные так называемые мэйнфреймовые компьютеры: VAX, DECVAX, HP

43
00:05:41,950000 --> 00:05:44,160000
IBM, я уже упоминал о многих других.

44
00:05:44,160000 --> 00:05:46,010000
многие из этих названий уже исчезли.

45
00:05:46,630000 --> 00:05:48,210000
все они занимались своими делами.

46
00:05:48,590000 --> 00:05:50,810000
никто из них на самом деле не хотел менять то, чем они занимались.

47
00:05:50,830000 --> 00:06:02,730000
но потом случилось то, что персональные компьютеры стремительно развивались, особенно с появлением чипов Intel, которые были приняты IBM и IBM PC.

48
00:06:04,030000 --> 00:06:18,690000
а затем и все другие производители микропроцессорных чипов, которые использовались в ПК, в частности Motorola, все они приняли тот же стандарт, с та же стандартная арифметика.

49
00:06:18,950000 --> 00:06:26,010000
и в конечном итоге все мэйнфреймы исчезли, как и большие машины IBM, которые полностью доминировали в вычислительной технике в 60-х и 70-х годах.

50
00:06:26,350000 --> 00:06:28,520000
люди больше не использовали их так часто.

51
00:06:28,520000 --> 00:06:34,090000
люди гораздо чаще использовали новые чипы Intel, которые продолжали развиваться на протяжении многих лет.

52
00:06:34,470000 --> 00:06:37,010000
так что стандарт оказался чрезвычайно успешным.

53
00:06:37,110000 --> 00:06:40,570000
индустрия действительно приняла изменения.

54
00:06:42,150000 --> 00:06:57,410000
но с точки зрения того, что произошло с тех пор, основные принципы стандарта, о которых я подробнее расскажу позже, по-прежнему широко применяются.

55
00:06:57,910000 --> 00:07:04,850000
но это 32-разрядные и 64-разрядные слова с плавающей запятой, одинарный и двойной форматы.

56
00:07:06,070000 --> 00:07:21,080000
и что произошло совсем недавно, так это то, что из-за огромного объема вычислений, необходимых для машинного обучения, различные компании производят чипы, используемые машинами

57
00:07:21,080000 --> 00:07:25,660000
learning, включая Google и NVIDIA

58
00:07:25,660000 --> 00:07:39,050000
в частности, они начали использовать эти более короткие форматы, 16-битный и даже 8-битный, а теперь даже 4-битный формат с плавающей запятой, который, в общем-то, неточен.

59
00:07:39,310000 --> 00:07:40,360000
это кардинальное изменение.

60
00:07:40,360000 --> 00:07:41,380000
это очень неточно.

61
00:07:41,380000 --> 00:07:41,760000
да.

62
00:07:41,760000 --> 00:07:43,210000
можно сказать, что это пугает.

63
00:07:45,070000 --> 00:07:48,130000
мы могли бы подробнее поговорить об этом позже, но да, вернемся к тебе.

64
00:07:48,750000 --> 00:07:56,610000
так что да, большое спасибо за это очень краткое и глубокое введение в историю с плавающей запятой.

65
00:07:56,790000 --> 00:08:05,050000
вы упомянули, что стандарт IEEE оказал огромное влияние на индустрию.

66
00:08:05,270000 --> 00:08:11,890000
а почему именно этот стандарт победил в гонке среди многих других?

67
00:08:12,470000 --> 00:08:14,480000
ну, на самом деле, это был единственный стандарт.

68
00:08:14,480000 --> 00:08:23,240000
случилось так, что все эти разные производители занимались своими делами, и стандарт сказал: "Нет, давайте все сделаем так".

69
00:08:23,240000 --> 00:08:25,170000
и не было никакого конкурирующего стандарта.

70
00:08:25,190000 --> 00:08:40,260000
и, как я уже сказал, из-за феноменального роста индустрии персональных компьютеров и используемых чипов, извините, но в этой отрасли, особенно в области чипов Intel и...

71
00:08:40,260000 --> 00:08:44,330000
чипов Motorola, все они просто приняли этот стандарт.

72
00:08:45,670000 --> 00:08:48,050000
они все согласились с тем, что это хорошая идея.

73
00:08:48,190000 --> 00:08:52,530000
тогда программы людей будут работать так, как ожидалось, на разных компьютерах.

74
00:08:54,070000 --> 00:08:57,130000
таким образом, на самом деле не существовало конкурирующего стандарта.

75
00:08:57,270000 --> 00:09:12,930000
в комитете, в который входили ученые-компьютерщики во главе с Каханом, а также множество представителей индустрии из всех крупных компаний, было много споров. известные в то время компании: IBM, HP и так далее, ДЕКАБРЬ.

76
00:09:13,470000 --> 00:09:18,370000
и они все спорили, конечно, не все пришли к единому мнению о том, что следует делать в первую очередь.

77
00:09:18,590000 --> 00:09:28,060000
но точка зрения Кахана была, ну, очень убедительной, но в то же время очень хорошо обоснованной с точки зрения теории и здравого смысла.

78
00:09:28,060000 --> 00:09:37,010000
и еще одна вещь, которая, как мне кажется, очень помогла, заключается в том, что Кахан является профессором компьютерных наук и математики, я думаю, и в Беркли.

79
00:09:37,550000 --> 00:09:43,740000
но также он приехал из Торонто, где на самом деле получил обширную подготовку в области электронного обучения, а также в области электротехники.

80
00:09:43,740000 --> 00:09:48,020000
так что он знал, о чем говорил, когда начинал, когда говорил об оборудовании.

81
00:09:48,020000 --> 00:09:50,810000
Он не был каким-то парнем, который не разбирался ни в чем из этого.

82
00:09:53,790000 --> 00:09:55,530000
короче говоря, они к нему прислушивались.

83
00:09:56,750000 --> 00:09:59,930000
я думаю, что в "стандарде" много замечательного.

84
00:10:00,270000 --> 00:10:05,540000
но я также хочу обратить внимание на некоторые проблемы, которые могут быть скрыты в этом стандарте.

85
00:10:05,540000 --> 00:10:08,620000
у тебя есть какие-нибудь существующие примеры?

86
00:10:08,620000 --> 00:10:13,970000
например, в своей книге вы упомянули, что постепенное уменьшение объема является наиболее спорной частью стандарта.

87
00:10:14,190000 --> 00:10:18,080000
так оно и было, но одна вещь, которая изменилась, заключается в том, что это больше не вызывает споров.

88
00:10:18,080000 --> 00:10:20,560000
это в значительной степени нашло применение в аппаратном обеспечении.

89
00:10:20,560000 --> 00:10:27,010000
случилось так, что для того, чтобы... ну, может быть, сначала нам следует объяснить нашим слушателям, что такое постепенный сброс.

90
00:10:28,990000 --> 00:10:33,650000
в формате с плавающей запятой у вас есть только, скажем, 32 бита.

91
00:10:34,870000 --> 00:10:40,810000
давайте сначала объясним, как, прежде чем мы перейдем к "недостаточному потоку", давайте объясним, как используются эти 32 бита.

92
00:10:41,070000 --> 00:10:44,970000
итак, есть один бит, который необходим для обозначения знака числа, плюс или минус.

93
00:10:45,390000 --> 00:10:47,170000
так что теперь у тебя осталось 31.

94
00:10:47,390000 --> 00:10:58,650000
так вот, в формате, который они согласились принять по разным причинам, следующие восемь битов использовались для представления показателя степени с плавающей запятой.

95
00:10:58,830000 --> 00:11:14,450000
итак, система с плавающей запятой - это система, которую иногда сравнивают с научной нотацией, где у вас есть, скажем так, простейший пример, давайте возьмем число 16.

96
00:11:14,550000 --> 00:11:16,370000
16 - это 2 в степени 4.

97
00:11:16,510000 --> 00:11:21,130000
ну, в двоичном формате, потому что мы всегда используем двоичный код с плавающей запятой, это совсем другая история.

98
00:11:21,270000 --> 00:11:25,330000
на самом деле существует десятичная точка, десятичная точка с плавающей запятой два, которая используется в бизнесе.

99
00:11:25,510000 --> 00:11:32,770000
но с научной точки зрения, в научных приложениях, в подавляющем большинстве приложений, используется двоичная точка с плавающей запятой.

100
00:11:33,150000 --> 00:11:43,370000
итак, число 16 в двоичной системе счисления равно 1,0000 и так далее, столько нулей, сколько вы хотите, умножьте на 2 в степени 4, получится 16.

101
00:11:43,950000 --> 00:11:50,130000
16 - это 2, умноженное на 2, умноженное на 2, умноженное на 2, умноженное на 2, 16.

102
00:11:50,310000 --> 00:11:59,850000
таким образом, число 4 хранится в поле экспоненты 32-битного слова.

103
00:12:00,190000 --> 00:12:11,690000
у вас есть до 8 бит, так что вы можете увеличить показатель примерно до 127, потому что вы также должны учитывать отрицательные показатели.

104
00:12:12,830000 --> 00:12:21,450000
а затем оставшиеся 23 бита в слове, верно, потому что их 32, но мы использовали 1 для минуса, 8 для показателя степени, это для так называемого значимого показателя.

105
00:12:21,590000 --> 00:12:27,980000
так что в случае с числом 16, поскольку оно в точности соответствует степени 2, получается просто 1.000, а затем куча нулей.

106
00:12:27,980000 --> 00:12:43,000000
но более сложное число, такое как пи, конечно, или даже что-то вроде, скажем, почти любого числа на самом деле, не будет равно 1.000, но так и будет, вы знаете, так и будет

107
00:12:43,000000 --> 00:12:45,690000
чтобы в расширении была куча единиц и нулей.

108
00:12:47,110000 --> 00:12:54,410000
таким образом, у вас есть 23 бита для этого значения, плюс еще один бит, который называется скрытым, но давайте пока оставим это в стороне.

109
00:12:54,830000 --> 00:12:57,890000
а затем у вас есть эти восемь бит для показателя степени.

110
00:12:58,070000 --> 00:13:05,560000
а показатель степени, как я уже сказал, варьируется примерно от минус 127 до плюс 127.

111
00:13:05,560000 --> 00:13:12,050000
есть пара специальных показателей степени, которые представляют особые числа, такие как ноль и бесконечность, что является еще одним интересным числом.

112
00:13:13,230000 --> 00:13:28,380000
но дело в постепенном уменьшении числа - это то, что происходит, когда число опускается до 2 до минус 126, я думаю, что это так и есть, ниже этого, вы могли бы сказать, ну послушайте, мы не можем сохранить число, которое меньше этого, так что

113
00:13:28,380000 --> 00:13:29,920000
нам придется снизить этот показатель до нуля.

114
00:13:29,920000 --> 00:13:34,610000
это будет не постепенный сброс, а резкий сброс.

115
00:13:34,710000 --> 00:13:51,130000
но постепенный сброс говорит о том, что, ну, нет, на самом деле, если быть немного умнее, мы действительно можем сохранить 2 до минус 127, 2 до минус 128, вплоть до того, что на самом деле это от 2 до минус 149 в так называемой одинарной точности, в 32-битном формате.

116
00:13:51,510000 --> 00:13:54,080000
вот что такое постепенный отток.

117
00:13:54,080000 --> 00:14:09,160000
так вот, как я уже сказал, это было спорно, потому что реализация арифметики с числами, которые могут быть так называемыми субнормальными, означает, что они опустились ниже этого порога оттока в субнормальный диапазон, используя постепенный отток

118
00:14:09,160000 --> 00:14:17,490000
в underflow используется арифметика, которая работает как с числами такого типа, так и с обычными числами с плавающей запятой, нормализованными.

119
00:14:18,150000 --> 00:14:23,620000
ну что ж, это дороже, сложнее, и многие производители просто не хотели этого делать.

120
00:14:23,620000 --> 00:14:25,820000
компания DEC, в частности, была категорически против этого.

121
00:14:25,820000 --> 00:14:30,770000
но Intel была в восторге, вероятно, из-за влияния Кахана.

122
00:14:32,350000 --> 00:14:45,090000
но в конце концов все поняли, что им было разрешено делать это в программном обеспечении, чтобы соответствовать стандарту, но это было проблемой, потому что тогда машины действительно могли бы выполнять вычисления. притормози.

123
00:14:46,550000 --> 00:14:55,200000
так что, в конце концов, практически все перешли на постепенный отказ от аппаратного обеспечения.

124
00:14:55,200000 --> 00:14:58,370000
так что на самом деле это уже не вызывает споров, но так было тогда.

125
00:14:59,350000 --> 00:15:02,010000
так что это одна из тех вещей, которые изменились к лучшему.

126
00:15:02,750000 --> 00:15:05,090000
может быть, есть какие-то другие примеры.

127
00:15:06,470000 --> 00:15:11,210000
ну что ж, самый важный из них на данный момент - это короткий формат для машинного обучения.

128
00:15:12,710000 --> 00:15:15,250000
не могли бы вы рассказать об этом чуть подробнее, пожалуйста?

129
00:15:15,310000 --> 00:15:15,930000
конечно.

130
00:15:19,110000 --> 00:15:24,080000
итак, стандарт определяет несколько форматов с плавающей запятой.

131
00:15:24,080000 --> 00:15:27,930000
32-битный формат - это так называемая одинарная точность.

132
00:15:28,070000 --> 00:15:30,210000
на языке Си это называется float.

133
00:15:31,390000 --> 00:15:36,440000
64-битный формат double - это двойная точность, на языке Си это называется double.

134
00:15:36,440000 --> 00:15:38,440000
я думаю, в Python это называется float, верно?

135
00:15:38,440000 --> 00:15:40,440000
это то, что тебя, по-видимому, интересует.

136
00:15:40,440000 --> 00:15:47,930000
потому что Python, по крайней мере, оригинальный Python, работает только с 64-битными числами с плавающей запятой двойной точности.

137
00:15:48,430000 --> 00:15:50,780000
насколько я понимаю, пожалуйста, поправьте меня, если я ошибаюсь.

138
00:15:50,780000 --> 00:15:51,770000
да, все правильно.

139
00:15:51,830000 --> 00:15:52,450000
да.

140
00:15:55,990000 --> 00:15:58,920000
хорошо, тогда как насчет более длинных и более коротких форматов?

141
00:15:58,920000 --> 00:16:11,090000
ну что ж, в формате 1985 года, стандарте 1985 года, были введены только одинарные и двойные форматы, и они сказали, что для соответствия стандарту необходимо использовать одинарные форматы.

142
00:16:11,110000 --> 00:16:13,210000
и вы также можете использовать двойные форматы, если хотите.

143
00:16:14,310000 --> 00:16:18,410000
и они рекомендовали расширенный формат, но это не так интересно.

144
00:16:19,190000 --> 00:16:24,960000
так вот, предполагается, что стандарт пересматривается каждые 10 лет, потому что в противном случае срок его действия истекает.

145
00:16:24,960000 --> 00:16:26,410000
это правило IEEE.

146
00:16:27,470000 --> 00:16:32,120000
это означает, что он должен был быть пересмотрен в 2005 году.

147
00:16:32,120000 --> 00:16:35,810000
на самом деле, редакция, наконец, появилась в 2008 году после долгих обсуждений.

148
00:16:35,830000 --> 00:16:38,410000
в 2008 году было внесено довольно много изменений.

149
00:16:38,590000 --> 00:16:46,260000
так что они ввели 128-битный формат, который иногда называют четырехкратной точностью.

150
00:16:46,260000 --> 00:16:50,490000
у вас есть одинарная, двойная, четырехкратная точность, 32, 64, 128 бит.

151
00:16:51,030000 --> 00:16:54,240000
и они также ввели половинную точность, которая составляет 16 бит.

152
00:16:54,240000 --> 00:16:58,720000
но этого становится все меньше, потому что для обозначения знака все равно нужен один бит.

153
00:16:58,720000 --> 00:17:11,650000
теперь, я думаю, в стандарте IEEE half precision у вас есть пять битов для показателя степени, что означает, что показатель степени может увеличиваться только от 2 до 16, верно, от 2 от минус 16 до плюс 16, примерно, от 2 до плюс 16.

154
00:17:16,070000 --> 00:17:24,010000
я думаю, что таким образом остается 10 бит для значения, плюс один так называемый скрытый бит, который присутствует во всех числах, кроме нуля.

155
00:17:27,950000 --> 00:17:30,360000
итак, был введен 16-битный формат.

156
00:17:30,360000 --> 00:17:35,880000
обычно это называется половинной точностью, или числом, названия также были изменены.

157
00:17:35,880000 --> 00:17:42,210000
так что в 2008 году вместо одинарного и двойного чисел они стали называть их двоичными 32 и двоичными 64.

158
00:17:42,350000 --> 00:17:46,330000
часто это сокращается до FP 32 или FP 64.

159
00:17:46,790000 --> 00:17:53,410000
а затем двоичными 128 и двоичными 16, или BF 16, я имею в виду FP 16.

160
00:17:54,750000 --> 00:18:05,650000
но затем, в 2019 году, была проведена еще одна ревизия, опять же, с небольшим опозданием, на год позже, но это не было серьезной ревизией.

161
00:18:05,950000 --> 00:18:11,730000
в нем появилось несколько новых вещей и исправлена пара ошибок, но это не было чем-то особо важным.

162
00:18:11,790000 --> 00:18:17,930000
но между тем, в период с 2008 по 2016 год произошли большие изменения, и именно поэтому машинное обучение получило развитие.

163
00:18:18,230000 --> 00:18:25,130000
и вот что произошло: именно Google первым сказал: "Хорошо, давайте сделаем так"... Ну, это был не только Google.

164
00:18:25,670000 --> 00:18:40,290000
Группа людей, работающих в области машинного обучения, говорили: "Эй, давайте использовать 16-битный формат, потому что, когда вы говорите о умножении двух 16-битных чисел, это очень много"

165
00:18:41,950000 --> 00:18:49,090000
этот процесс требует гораздо меньше энергии, чем умножение 32-битных чисел.

166
00:18:51,110000 --> 00:18:56,210000
таким образом, вы экономите энергию и пространство за счет использования более коротких форматов.

167
00:18:57,310000 --> 00:19:00,410000
до появления машинного обучения это не было такой уж большой проблемой.

168
00:19:00,590000 --> 00:19:05,600000
но что произошло с машинным обучением, так это то, что в нем задействовано огромное количество вычислений.

169
00:19:05,600000 --> 00:19:12,330000
и причина, по которой машинное обучение внезапно стало таким успешным, заключается в том, что теперь это возможно благодаря современным технологиям.

170
00:19:12,790000 --> 00:19:16,260000
раньше было невозможно выполнять такие масштабные вычисления.

171
00:19:16,260000 --> 00:19:17,930000
это было просто слишком дорого.

172
00:19:18,670000 --> 00:19:23,410000
но сейчас, когда компьютеры становятся все быстрее и дешевле, теперь это возможно.

173
00:19:23,550000 --> 00:19:38,680000
вся идея нейронных сетей, которую продвигали Ян Лекун и другие еще до начала века, я думаю, он как бы говорил, понимаете, он

174
00:19:38,680000 --> 00:19:43,500000
я был вроде как не совсем одинок в дикой местности, но люди не были уверены, что нейронные сети вообще могут работать.

175
00:19:43,500000 --> 00:19:48,850000
а потом, примерно к 2010 году или около того, стало совершенно ясно, что они удивительно эффективны.

176
00:19:48,990000 --> 00:20:04,170000
а к 2015 или 16 году такие компании, как Google, которые разрабатывали свой TPU, тензорный процессор, поняли, что, хорошо, если мы будем использовать 16 бит, это будет намного быстрее и дешевле.

177
00:20:05,430000 --> 00:20:17,050000
но на самом деле, давайте введем новый формат, - сказали они, - потому что им не понравилось двоичное число 16, потому что диапазон значений экспоненты очень мал - от 2 до минус 16 и от 2 до 16.

178
00:20:17,670000 --> 00:20:22,370000
так вот, они представили нечто, что они назвали bfloat 16.

179
00:20:22,710000 --> 00:20:25,130000
B означает "мозг", Google brain.

180
00:20:26,390000 --> 00:20:29,690000
и в этом формате у вас все еще остается один бит для обозначения знака.

181
00:20:30,510000 --> 00:20:37,730000
но теперь у вас есть восемь бит для показателя степени, что соответствует стандарту IEEE single precision.

182
00:20:38,510000 --> 00:20:42,290000
ну и ладно, тогда получается, что используется девять из ваших 16 бит.

183
00:20:42,590000 --> 00:20:45,050000
и что же у тебя осталось?

184
00:20:45,270000 --> 00:20:55,330000
теперь у тебя осталось семь бит плюс один скрытый бит, которого недостаточно даже для того, чтобы представить точность более двух десятичных разрядов.

185
00:20:57,190000 --> 00:21:02,010000
возможно, это не так очевидно, но мы могли бы поговорить об этом позже, если это представляет интерес.

186
00:21:05,270000 --> 00:21:13,500000
люди были немного шокированы тем, что в цифрах так мало точности, но они сказали: "Слушай, эй, это же машинное обучение".

187
00:21:13,500000 --> 00:21:18,770000
мы выполняем огромные объемы ИТ-работ, и у нас много избыточности, и нам не нужна высокая точность.

188
00:21:22,710000 --> 00:21:28,100000
вы не можешь спорить с тем фактом, что машинное обучение оказалось чрезвычайно успешным, так что, по-видимому, оно работает.

189
00:21:28,100000 --> 00:21:35,010000
вряд ли тебе захочется делать это для решения научных задач, требующих высокоточных вычислений.

190
00:21:35,950000 --> 00:21:40,170000
но в машинном обучении, похоже, в этом нет необходимости.

191
00:21:41,390000 --> 00:21:44,570000
поэтому они представили BFLOAT 16 и создали свои собственные чипы.

192
00:21:45,390000 --> 00:21:47,770000
они не особо скрывали это.

193
00:21:50,790000 --> 00:21:52,130000
они действительно опубликовали это.

194
00:21:53,030000 --> 00:22:04,410000
а затем другие производители начали придерживаться того же формата, включая NVIDIA и Intel, которые, как я полагаю, являются двумя крупнейшими игроками, производящими чипы на данный момент.

195
00:22:08,230000 --> 00:22:13,210000
ну, может быть, еще один или два, но в любом случае, это, безусловно, два очень крупных производителя.

196
00:22:19,830000 --> 00:22:21,050000
так что все в порядке.

197
00:22:22,310000 --> 00:22:25,600000
тогда люди сказали: "Ну, послушай, если 16 бит, то почему не 8 бит"?

198
00:22:25,600000 --> 00:22:31,650000
так вот, группа исследователей начала использовать 8 бит, сначала просто имитируя это, потому что у них не было 8-битного оборудования.

199
00:22:32,390000 --> 00:22:37,490000
но с другой стороны, производители начали создавать 8-битное оборудование.

200
00:22:37,910000 --> 00:22:42,610000
так что и Intel, и NVIDIA выпустили 8-битные чипы с плавающей запятой.

201
00:22:42,950000 --> 00:22:44,890000
ну что ж, этого становится все меньше.

202
00:22:45,190000 --> 00:22:57,900000
а теперь последняя новость: всего несколько месяцев назад, я думаю, это было в апреле или около того, NVIDIA объявила, что они выпускают 4-битные чипы с плавающей запятой, что в некотором роде шокирует.

203
00:22:57,900000 --> 00:22:58,970000
я имею в виду, что это только начало.

204
00:22:59,190000 --> 00:23:03,860000
я даже не знаю, как представить их двоичную структуру.

205
00:23:03,860000 --> 00:23:15,050000
итак, первый бит, очевидно, обозначает знак, затем два бита, я полагаю, обозначают показатель степени и один бит - мантиссу.

206
00:23:15,910000 --> 00:23:18,250000
да, мантисса - это еще одно слово, обозначающее значение.

207
00:23:19,510000 --> 00:23:21,570000
это прекрасно, только для нашей аудитории.

208
00:23:23,030000 --> 00:23:26,760000
да, именно так, плюс один скрытый бит, который дает вам два бита для значения.

209
00:23:26,760000 --> 00:23:29,250000
на самом деле я не уверен, так ли это на самом деле.

210
00:23:29,310000 --> 00:23:31,860000
скорее всего, так оно и есть, или, может быть, на один бит меньше для показателя степени.

211
00:23:31,860000 --> 00:23:32,260000
я не уверен.

212
00:23:32,260000 --> 00:23:33,240000
я еще не проверял это.

213
00:23:33,240000 --> 00:23:35,010000
я планирую сделать это очень скоро.

214
00:23:36,710000 --> 00:23:39,490000
в любом случае, где же предел?

215
00:23:39,990000 --> 00:23:42,010000
да, это довольно интересно.

216
00:23:42,790000 --> 00:23:46,810000
вы также довольно часто упоминал об этом скрытом бите.

217
00:23:46,870000 --> 00:23:49,770000
так что не могли бы вы, пожалуйста, объяснить, что такое скрытый бит?

218
00:23:49,910000 --> 00:23:57,020000
каждое число, каждая двоичная система, каждое число, за исключением нуля, имеет начальную единицу, верно?

219
00:23:57,020000 --> 00:24:06,060000
поскольку вы всегда можете это сделать, весь смысл использования плавающей запятой заключается в том, что вы нормализуете, сдвигаете двоичную точку так, чтобы она переместилась в нужное положение.

220
00:24:06,060000 --> 00:24:07,400000
вот почему это называется плавающей запятой.

221
00:24:07,400000 --> 00:24:13,600000
она перемещается в положение, где единица находится впереди двоичной точки, а затем ноль, ноль, ноль.

222
00:24:13,600000 --> 00:24:20,820000
дело в том, что все числа, будь то число пи, квадратный корень из двух или одна десятая, представляют интерес.

223
00:24:20,820000 --> 00:24:21,690000
давай попробуем именно это.

224
00:24:21,710000 --> 00:24:36,730000
одна десятая равна 1,100110011001100 точка-точка-точка, умноженная на 2 с минусом

225
00:24:37,310000 --> 00:24:39,290000
ему 4 года, если я правильно помню.

226
00:24:39,430000 --> 00:24:41,450000
для этого мне нужно воспользоваться калькулятором.

227
00:24:46,190000 --> 00:24:48,130000
получается, что это одна десятая часть.

228
00:24:48,270000 --> 00:24:48,890000
все в порядке.

229
00:24:49,350000 --> 00:24:50,650000
примерно одна десятая часть, да.

230
00:24:51,150000 --> 00:24:54,130000
да, именно так, если вы будешь продолжать в том же духе вечно.

231
00:24:55,150000 --> 00:24:57,080000
но опять же, как видишь, все начинается с 1.

232
00:24:57,080000 --> 00:25:02,330000
ну, конечно же, все начинается с 1, потому что я расставил двоичную точку так, чтобы впереди была 1.

233
00:25:02,830000 --> 00:25:06,090000
я не ставил 0,0001100.

234
00:25:06,310000 --> 00:25:15,690000
я мог бы это сделать, но весь смысл плавающей точки в том, что вы хотите переместить эту двоичную точку, чтобы получить значение один впереди, и тогда у тебя будет в разы больше силы.

235
00:25:16,110000 --> 00:25:19,090000
а вот тот, что спереди, зачем нам его хранить?

236
00:25:19,350000 --> 00:25:22,210000
мы знаем, что это единица, так что это скрытый бит.

237
00:25:22,390000 --> 00:25:33,610000
так вот, до появления стандарта, на самом деле именно Vax первым начал это делать, DEC VAX, но до появления DEC VAX Люди сохраняли это, и причина в том, что им нужен был способ записать ноль.

238
00:25:33,870000 --> 00:25:35,130000
а ноль равен 0,000.

239
00:25:36,150000 --> 00:25:39,360000
вы не можете заменить двоичную точку на ноль, чтобы получить единицу впереди.

240
00:25:39,360000 --> 00:25:40,220000
здесь никого нет.

241
00:25:40,220000 --> 00:25:41,530000
там сплошные нули.

242
00:25:41,550000 --> 00:25:46,970000
но, видишь ли, вместо нуля можно использовать специальный показатель степени.

243
00:25:47,670000 --> 00:26:02,740000
так что, возвращаясь к 32-битному формату, я сказал, что цифры - это что-то вроде от минус 126 до плюс 127, но при этом остается пара свободных чисел, и

244
00:26:02,740000 --> 00:26:07,930000
число, которое соответствует минус 127, соответствует нулю.

245
00:26:08,630000 --> 00:26:19,170000
число, находящееся на другом конце диапазона, показатель степени 128, по-моему, или, может быть, 127, соответствует бесконечности.

246
00:26:19,430000 --> 00:26:26,410000
потому что в арифметике IEEE единица, деленная на ноль, равна бесконечности.

247
00:26:26,550000 --> 00:26:27,170000
да.

248
00:26:28,310000 --> 00:26:30,210000
но это очень интересная часть.

249
00:26:30,270000 --> 00:26:36,250000
в некоторых языках это считается бесконечностью, но в некоторых языках есть исключения.

250
00:26:36,310000 --> 00:26:38,100000
например, CPython делает это.

251
00:26:38,100000 --> 00:26:40,690000
в этом случае возникает исключение с нулевым делением.

252
00:26:41,030000 --> 00:26:47,170000
так что вы думаете по поводу этого небольшого неверного толкования стандарта?

253
00:26:47,630000 --> 00:26:48,800000
ну что ж, это очень хороший вопрос.

254
00:26:48,800000 --> 00:26:50,970000
я не думаю, что это неправильное толкование.

255
00:26:51,110000 --> 00:27:02,810000
суть в том, что число становится бесконечным, но, согласно стандарту, это исключение, когда вы делите на ноль, это исключение.

256
00:27:02,830000 --> 00:27:05,850000
это исключение при делении на ноль.

257
00:27:06,190000 --> 00:27:14,370000
что происходит в CPython, так это то, что CPython перехватывает исключение и говорит: "Хорошо, остановись".

258
00:27:16,990000 --> 00:27:22,690000
исключение генерируется чипом.

259
00:27:24,350000 --> 00:27:26,520000
в системе с плавающей запятой существуют различные исключения.

260
00:27:26,520000 --> 00:27:28,010000
одно из них - деление на ноль.

261
00:27:28,710000 --> 00:27:33,690000
еще одно - переполнение, когда число становится настолько большим, что оно больше не помещается.

262
00:27:34,310000 --> 00:27:40,050000
еще одно - переполнение, когда число становится настолько маленьким, что оно больше не помещается, даже после того, как вы просмотрели все.

263
00:27:40,150000 --> 00:27:46,740000
на самом деле, флажок переполнения чрезвычайно сложен, потому что, как мне кажется, он устанавливается даже тогда, когда вы переходите в диапазон постепенного переполнения.

264
00:27:46,740000 --> 00:27:50,490000
вам стоит заглянуть в мою книгу, особенно во второе издание, чтобы все это понять.

265
00:27:51,470000 --> 00:27:54,210000
мы добавим ссылку в описание.

266
00:27:55,070000 --> 00:28:00,460000
да, у меня еще не готово второе издание, но я пришлю вам копию, как только она будет готова.

267
00:28:00,460000 --> 00:28:01,480000
О, спасибо тебе.

268
00:28:01,480000 --> 00:28:02,210000
это потрясающе.

269
00:28:03,710000 --> 00:28:08,130000
но она будет опубликована издательством SIAM, надеюсь, в 2025 году.

270
00:28:08,830000 --> 00:28:10,370000
я уже довольно близок к этому.

271
00:28:12,630000 --> 00:28:14,640000
да, так что есть пять исключений.

272
00:28:14,640000 --> 00:28:18,610000
Делим на 0, получаем переполнение, недополучение.

273
00:28:20,510000 --> 00:28:24,370000
еще одно интересное исключение - недопустимая операция.

274
00:28:24,430000 --> 00:28:37,530000
итак, умножение нуля на ноль является недопустимой операцией и генерирует NaN, которое не является числом.

275
00:28:38,950000 --> 00:28:46,810000
это еще один особый шаблон в системе с плавающей запятой, использующий максимально возможный показатель степени.

276
00:28:48,270000 --> 00:28:52,730000
так что опять же, вероятно, CPython перехватит это и остановится, я полагаю, верно?

277
00:28:54,270000 --> 00:29:01,490000
Но разве нет способа настроить компилятор так, чтобы он работал с бесконечностями и NaN или нет?

278
00:29:03,190000 --> 00:29:04,330000
я так не думаю.

279
00:29:04,750000 --> 00:29:10,530000
там может быть какой-то скрытый недокументированный флаг или что-то в этом роде, но я не думаю, что есть документированный способ сделать это.

280
00:29:11,670000 --> 00:29:26,720000
я удивлен этому, потому что это определенно есть в C. И в статистике C, C, а также Fortran потребовалось много времени, чтобы догнать C. стандарт, даже несмотря на то, что C был серьезно пересмотрен в 1999 году, что произошло намного позже выхода стандарта

281
00:29:26,720000 --> 00:29:28,170000
это было опубликовано 14 лет спустя.

282
00:29:28,270000 --> 00:29:32,970000
на самом деле в нем даже не упоминалось об этом, а может, и упоминалось, но это не имело особого значения.

283
00:29:36,590000 --> 00:29:37,940000
прости, я что-то не так понял.

284
00:29:37,940000 --> 00:29:39,090000
это было в 1989 году.

285
00:29:39,270000 --> 00:29:44,010000
в 1999 году они, наконец, догнали стандарт и внесли много изменений.

286
00:29:45,070000 --> 00:29:49,530000
на самом деле, Нельсон Биб - эксперт, самый большой специалист по плавающей запятой в Си.

287
00:29:51,470000 --> 00:30:01,500000
так вот, в Си обычное поведение по умолчанию заключается в том, что вы генерируете бесконечности и NaN.

288
00:30:01,500000 --> 00:30:08,610000
и это позволяет вам делать что-то вроде: вот один пример, который мне нравится, - это формула параллельного сопротивления.

289
00:30:08,710000 --> 00:30:12,250000
так что, если у вас есть два резистора, подключите их параллельно.

290
00:30:12,750000 --> 00:30:15,300000
это то, чему учат еще в старших классах.

291
00:30:15,300000 --> 00:30:17,010000
у вас в учебнике есть такой пример.

292
00:30:17,110000 --> 00:30:18,250000
да, именно так.

293
00:30:18,430000 --> 00:30:19,810000
вот он, этот пример.

294
00:30:20,190000 --> 00:30:30,530000
формула параллельного сопротивления заключается в том, что у вас есть два резистора, подключенных параллельно к цепи: 1/(1/ R1 + 1/ R2), и один из резисторов имеет сопротивление R1 а другой - R2.

295
00:30:30,830000 --> 00:30:33,040000
а вот и формула для расчета суммарного сопротивления.

296
00:30:33,040000 --> 00:30:37,940000
так что, если они одинаковы, если R1 и R2 равны 1, то получается 1 на 2.

297
00:30:37,940000 --> 00:30:42,040000
таким образом, результат равен половине, потому что половина тока идет в одну сторону, а половина - в другую.

298
00:30:42,040000 --> 00:30:43,210000
так что в этом есть смысл.

299
00:30:43,590000 --> 00:30:45,890000
но что, если R1 очень мал?

300
00:30:45,990000 --> 00:31:00,370000
ну что ж, тогда вы видите, что большая часть тока проходит через резистор R1, и тогда общее сопротивление составляет 1 на 1 по сравнению с R1 плюс еще немного, что лишь немного меньше, чем R1

301
00:31:01,230000 --> 00:31:06,250000
потому что большая часть тока проходит через R1, когда R1 намного меньше, чем R2.

302
00:31:06,270000 --> 00:31:07,770000
а что, если R1 равно нулю?

303
00:31:08,110000 --> 00:31:15,780000
ну что ж, если вы вставите в эту формулу значение R1, равное нулю, вы не допустите бесконечности, и тогда это не сработает.

304
00:31:15,780000 --> 00:31:20,050000
но если вы допустите бесконечности, то получите 1, а не R1 - бесконечность.

305
00:31:21,350000 --> 00:31:23,160000
1, а не R2 - это, скажем, 1.

306
00:31:23,160000 --> 00:31:25,080000
1 плюс бесконечность - это бесконечность.

307
00:31:25,080000 --> 00:31:27,490000
и тогда 1 плюс бесконечность - это 0.

308
00:31:27,710000 --> 00:31:30,020000
таким образом, весь ток проходит через R1.

309
00:31:30,020000 --> 00:31:31,420000
в цепи нет сопротивления.

310
00:31:31,420000 --> 00:31:33,570000
так что это имеет научный смысл.

311
00:31:34,270000 --> 00:31:37,820000
сейчас, конечно, большинство людей не используют параллельные схемы для вычислений.

312
00:31:37,820000 --> 00:31:40,260000
но есть много примеров, подобных этому.

313
00:31:40,260000 --> 00:31:45,060000
и на самом деле это очень полезная вещь.

314
00:31:45,060000 --> 00:31:48,330000
так что я очень удивлен, что CPython этого не допускает.

315
00:31:49,590000 --> 00:31:52,050000
практически все другие языки, которые я знаю, допускают это.

316
00:31:52,550000 --> 00:31:53,930000
конечно же, MATLAB.

317
00:31:53,990000 --> 00:31:59,970000
мне придется перепроверить это прямо сейчас, потому что я начинаю сомневаться в себе.

318
00:32:00,630000 --> 00:32:04,090000
возможно, именно такую обстановку вы и должны выбрать.

319
00:32:04,750000 --> 00:32:07,240000
я уже дважды проверил это прямо сейчас.

320
00:32:07,240000 --> 00:32:11,090000
так что вы не можете настроить CPython так, чтобы он не выдавал эту ошибку.

321
00:32:11,270000 --> 00:32:26,520000
я думаю, что главная причина этого в том, что Python старается быть максимально удобным для пользователя, и я вижу множество примеров использования, в которых Infinity не очень удобен для пользователя.

322
00:32:26,520000 --> 00:32:27,610000
вы согласны с этим?

323
00:32:29,070000 --> 00:32:33,980000
я думаю, что это нечто такое, что, да, у многих людей на этот счет разные мнения.

324
00:32:33,980000 --> 00:32:40,500000
да, конечно, если вы понимаете, что Бесконечность имеет смысл, но, конечно, на самом деле это не так.

325
00:32:40,500000 --> 00:32:43,530000
по сути, они говорят тебе: "Послушай, в этом нет никакого смысла".

326
00:32:43,710000 --> 00:32:55,810000
люди иногда используют NaNS для инициализации данных, а затем для данных, которые должны быть затем установлены на другие значения, и если в конце что-то все еще остается NaN, вы знаете, что что-то не так.

327
00:32:56,550000 --> 00:32:59,250000
насколько я знаю, это называется "сигнал и NaN".

328
00:32:59,310000 --> 00:33:05,970000
есть два вида NaN: сигнальные NaN и тихие NaN, и разница довольно сложная.

329
00:33:12,990000 --> 00:33:23,500000
если тебе интересно, я могу немного рассказать тебе о том, что происходит с NaN, давай посмотрим, закончили ли мы с исключением?

330
00:33:23,500000 --> 00:33:25,700000
может быть, я просто повторю еще раз об исключениях.

331
00:33:25,700000 --> 00:33:28,010000
да, итак, есть пять исключений.

332
00:33:28,190000 --> 00:33:42,600000
есть деление на ноль, переполнение, недостаточный поток, недопустимая операция, которая представляет собой что-то вроде умножения нуля на ноль, или квадратный корень из минус единицы будет еще одной недопустимой операцией, если только вы не находитесь в каком-то из режима, подобного MATLAB, где вы разрешаете

333
00:33:42,600000 --> 00:33:43,650000
это комплексные числа.

334
00:33:47,470000 --> 00:33:54,730000
и еще одним примером некорректной операции может быть бесконечность минус бесконечность, потому что, знаете ли, не имеет смысла, какое из них больше.

335
00:33:55,470000 --> 00:33:57,570000
Бесконечность плюс бесконечность - это бесконечность.

336
00:33:59,590000 --> 00:34:06,760000
пятое исключение - это когда результат вычисления не является точным, точным числом с плавающей запятой.

337
00:34:06,760000 --> 00:34:11,570000
но называть это исключением как-то неправильно, потому что на самом деле это происходит почти постоянно.

338
00:34:11,950000 --> 00:34:14,730000
но, как бы то ни было, по какой-то причине это все еще называется исключением.

339
00:34:15,470000 --> 00:34:17,650000
и для этого тоже есть соответствующий флажок.

340
00:34:17,750000 --> 00:34:25,530000
Но еще одна важная вещь, которая изменилась, заключается в том, что вся эта история с флагами, видите ли, раньше считалось, что устанавливать флаги - это хорошо.

341
00:34:26,910000 --> 00:34:37,580000
И потом, вы знаете, компилятор может, среда выполнения, процесс выполнения может проверять флаги и так далее.

342
00:34:37,580000 --> 00:34:45,330000
но сейчас, когда все эти гораздо более сложные вещи, такие как многопоточность и так далее, флаги действительно могут мешать.

343
00:34:47,550000 --> 00:34:49,160000
это действительно выходит за рамки моего опыта.

344
00:34:49,160000 --> 00:34:51,000000
я не компьютерный дизайнер.

345
00:34:51,000000 --> 00:35:01,090000
но, судя по тому, что я слышал, установка и проверка этих флагов исключений больше не вызывает особого энтузиазма.

346
00:35:02,230000 --> 00:35:04,380000
но с CPython это может быть не так.

347
00:35:04,380000 --> 00:35:05,810000
похоже, что, возможно, это не так.

348
00:35:08,190000 --> 00:35:10,580000
так что же происходит с плавающей точкой?

349
00:35:10,580000 --> 00:35:24,770000
что касается 8-разрядной системы с плавающей точкой, то теперь появился новый комитет IEEE под названием Committee P3109.

350
00:35:24,830000 --> 00:35:31,050000
первоначальный комитет IEEE, комитет по плавающей части, назывался IEEE P 754.

351
00:35:31,590000 --> 00:35:41,260000
и вы постоянно слышите об арифметике 754, IEEE 754. любой, кто много знает о плавающей части, слышал о 754.

352
00:35:41,260000 --> 00:35:43,610000
это просто означает стандарт IEEE с плавающей точкой.

353
00:35:44,590000 --> 00:35:46,440000
так это было в 1985 году.

354
00:35:46,440000 --> 00:35:48,400000
я думаю, они пронумеровали их последовательно.

355
00:35:48,400000 --> 00:35:53,530000
так что теперь у нас есть 3109 рабочих групп IEEE.

356
00:35:55,070000 --> 00:35:57,820000
но, конечно, не многие из них имеют отношение к операциям с плавающей запятой.

357
00:35:57,820000 --> 00:36:00,210000
IEEE - огромная организация.

358
00:36:02,990000 --> 00:36:17,010000
так что 3109 - это комитет, который был создан для определения и выработки рекомендаций по стандартизации 8-разрядной системы с плавающей запятой.

359
00:36:17,670000 --> 00:36:22,130000
и вот я связался с этими людьми, чтобы узнать больше об этом.

360
00:36:23,430000 --> 00:36:26,130000
и они сказали: "Ну что ж, послушай, почему бы тебе просто не присоединиться к комитету"?

361
00:36:26,790000 --> 00:36:27,900000
я так и сделал.

362
00:36:27,900000 --> 00:36:29,970000
и на самом деле, это было чрезвычайно интересно.

363
00:36:30,070000 --> 00:36:31,600000
о, я этого не знал.

364
00:36:31,600000 --> 00:36:32,810000
да, да.

365
00:36:33,790000 --> 00:36:37,580000
Потому что этот факт не был опубликован,

366
00:36:37,580000 --> 00:36:50,540000
но комитет 3109 только что опубликовал промежуточный отчет, в котором я принимал самое непосредственное участие вместе со всеми остальными членами комитета.

367
00:36:50,540000 --> 00:36:56,780000
в комитете есть несколько руководителей, секретарь.

368
00:36:56,780000 --> 00:36:58,500000
ну что ж, давайте не будем переходить на личности.

369
00:36:58,500000 --> 00:37:05,120000
но в любом случае, там много очень, очень компетентных людей, конечно, в основном это специалисты по машинному обучению.

370
00:37:05,120000 --> 00:37:07,520000
но есть и специалисты по плавающей запятой.

371
00:37:07,520000 --> 00:37:09,690000
ну, конечно, некоторые из них являются экспертами и в том, и в другом.

372
00:37:10,230000 --> 00:37:16,490000
я не очень разбираюсь в машинном обучении, но так что я здесь с точки зрения работы с плавающей запятой.

373
00:37:17,270000 --> 00:37:31,690000
но есть также куча специалистов по аппаратному обеспечению, таких как люди из Intel, и на самом деле, я не знаю, есть ли в комитете кто-нибудь из NVIDIA, но определенно есть кто-то из Intel и другие компании.

374
00:37:32,430000 --> 00:37:37,610000
итак, комитет по P3109 опубликовал промежуточный отчет.

375
00:37:37,710000 --> 00:37:45,850000
на данный момент неясно, какое влияние окажут рекомендации 3109 по сравнению с рекомендациями 754.

376
00:37:46,750000 --> 00:37:53,970000
потому что индустрия развивается очень быстро, и компании не ждут, что предпримет комитет.

377
00:37:55,350000 --> 00:37:58,640000
может быть, мы станем стандартизированными, следуя рекомендациям комитета.

378
00:37:58,640000 --> 00:37:59,930000
я думаю, именно на это мы и надеемся.

379
00:38:01,430000 --> 00:38:13,040000
рекомендации на данный момент заключаются в том, что, имея всего восемь заявок, вы должны быть немного более внимательны, вы должны быть очень внимательны к тому, для чего вы собираетесь их использовать.

380
00:38:13,040000 --> 00:38:21,290000
а теперь вернемся к 32-разрядному и 64-разрядному IEEE, оригинальным форматам с одинарной и двойной плавающей запятой, которые используются в основном.

381
00:38:23,390000 --> 00:38:38,450000
так вот, в этих форматах, как я уже сказал, есть специальные представления для бесконечности, также минус бесконечность, ноль, но также и минус ноль, который это еще одно осложнение, которое тоже было своего рода

382
00:38:39,430000 --> 00:38:47,090000
это спорно, потому что если у вас будет 1 над бесконечностью, то это 0, ну тогда не должно быть 1 над бесконечностью. минус бесконечность будет минус 0?

383
00:38:47,270000 --> 00:38:55,690000
и в любом случае, если вы собираетесь представлять 0, вам нужно что-то сделать со знаковым битом, так почему же он всегда должен быть положительным немного расписаться?

384
00:38:56,430000 --> 00:38:57,480000
а почему бы и не быть отрицательным?

385
00:38:57,480000 --> 00:39:03,720000
так что на самом деле в оригинальном формате IEEE существует два представления нуля.

386
00:39:03,720000 --> 00:39:05,440000
таким образом, есть ноль и есть минус ноль.

387
00:39:05,440000 --> 00:39:13,100000
но тогда это приводит к некоторым очень интересным неожиданным поведениям, потому что равен ли ноль минус нулю?

388
00:39:13,100000 --> 00:39:16,210000
если вы проверите это на таком языке программирования, как Python.

389
00:39:17,310000 --> 00:39:18,210000
да, так оно и есть.

390
00:39:18,270000 --> 00:39:19,770000
так оно и есть, все верно.

391
00:39:19,990000 --> 00:39:23,090000
извини, это не должно было быть экзаменационным вопросом, но вы совершенно правы.

392
00:39:23,750000 --> 00:39:26,580000
но, с другой стороны, равна ли бесконечность минус бесконечности?

393
00:39:26,580000 --> 00:39:27,780000
ну, это совершенно не так.

394
00:39:27,780000 --> 00:39:28,930000
они очень разные.

395
00:39:28,990000 --> 00:39:38,880000
так что это означает, что A может быть равно B, но 1 над A не равно 1 над B, где A и B равны 0 и минус 0.

396
00:39:38,880000 --> 00:39:41,850000
так что это, мягко говоря, сбивает с толку.

397
00:39:43,550000 --> 00:39:52,490000
но на самом деле выбор в пользу минус бесконечности на самом деле приводит к минус 0.

398
00:39:55,310000 --> 00:40:06,930000
и если у тебя будет 1, а не 0 - это бесконечность, то вы действительно как бы зацикливаетесь на идее, что если у тебя будет две бесконечности, то тебе нужно будет там тоже есть два нуля.

399
00:40:06,990000 --> 00:40:09,320000
ну что ж, на странице 3109 все это обсуждалось.

400
00:40:09,320000 --> 00:40:11,450000
на самом деле это было еще до того, как я присоединился к комитету.

401
00:40:12,270000 --> 00:40:23,250000
И решение, которое они приняли, или мы приняли, я полагаю, было таким: хотя я не принимал участия в самом начале, к лучшему это или к худшему, но будет только один ноль, без минусов. ноль в рекомендациях.

402
00:40:25,110000 --> 00:40:31,570000
кроме того, в IEEE есть несколько NaN.

403
00:40:31,870000 --> 00:40:34,800000
как вы заметили, есть сигнальные NaN и тихие NaN.

404
00:40:34,800000 --> 00:40:46,530000
и на самом деле это много разных NaN, потому что все, что вы можете сделать, это получить все эти дополнительные биты, которые вы все равно не используете, из поля значения, соответствующего специальному полю экспоненты для NaN.

405
00:40:46,710000 --> 00:40:50,130000
так что с таким же успехом вы могли бы использовать их для кодирования происхождения NaN.

406
00:40:51,270000 --> 00:40:53,690000
так что в IEEE существует множество различных NaN.

407
00:40:56,470000 --> 00:40:58,760000
вы не можешь проверить, равен ли один из них другому.

408
00:40:58,760000 --> 00:41:01,570000
NaN никогда не равен ничему, даже самому себе.

409
00:41:01,670000 --> 00:41:05,810000
но они все еще могут быть равны, битовые структуры все еще можно исследовать.

410
00:41:06,150000 --> 00:41:12,940000
окей, ну что ж, 3109 в 8-битном формате решили, что нет, нам не нужно так много NaN.

411
00:41:12,940000 --> 00:41:14,460000
мы не можем позволить себе такое пространство.

412
00:41:14,460000 --> 00:41:16,540000
так что там тоже будет только один NaN.

413
00:41:16,540000 --> 00:41:22,170000
и они используют битовую схему, которая обычно используется для обозначения минус нуля, для представления NaN.

414
00:41:22,870000 --> 00:41:26,010000
так что это означает, что у вас есть один ноль, один NaN.

415
00:41:26,710000 --> 00:41:28,730000
а как насчет бесконечностей?

416
00:41:29,150000 --> 00:41:44,300000
две бесконечности, но единица над нулем - это не бесконечность, потому что если бы это было так, а затем, если бы это было так, а затем вы взяли единицу над бесконечностью, это дало бы вам ноль, но единица, превышающая минус бесконечность, также даст вам ноль

417
00:41:44,300000 --> 00:41:48,650000
а если прибавить к этому единицу, то получится плюс бесконечность, что действительно приводит к путанице.

418
00:41:48,870000 --> 00:42:01,370000
так что рекомендация прямо сейчас, я не думаю, что это еще было опубликовано в промежуточном отчете, но, вероятно, будет рекомендовано, чтобы единица над нулем была равна NaN, а не бесконечность.

419
00:42:02,070000 --> 00:42:02,690000
ох.

420
00:42:06,350000 --> 00:42:09,000000
так вот в чем заключается текущее предложение.

421
00:42:09,000000 --> 00:42:11,170000
по-моему, по нему еще не проводилось голосование.

422
00:42:12,750000 --> 00:42:14,020000
каково твое мнение по этому поводу?

423
00:42:14,020000 --> 00:42:20,650000
потому что с математической точки зрения, я полагаю, что они одновременно и не имеют смысла, и имеют его на самом деле.

424
00:42:21,990000 --> 00:42:36,210000
ну что ж, я думаю, что мое мнение таково: комитет прав в том, что если у вас не будет минус нуля, а будет плюс или минус бесконечность, то вам следует не говорите, что 1 больше - это плюс бесконечность, потому что это слишком запутанно.

425
00:42:36,270000 --> 00:42:39,810000
просто хочу повторить то, что я только что сказал, потому что я ехал очень быстро.

426
00:42:39,830000 --> 00:42:46,020000
если у тебя минус бесконечность, то 1 на минус бесконечность будет равно 0, а затем 1 на 0, если это плюс бесконечность, то нет, это действительно плохо.

427
00:42:46,020000 --> 00:42:52,890000
в то время как в IEEE 1 на минус бесконечность будет равно минус 0, а затем 1 на минус 0 будет минус бесконечность, так что, по крайней мере, вы получите это обратно.

428
00:42:57,070000 --> 00:42:59,450000
тогда вы могли бы сказать: "Ну и что хорошего в бесконечностях"?

429
00:42:59,870000 --> 00:43:03,690000
смысл бесконечностей в том, чтобы использовать их, когда возникает переполнение.

430
00:43:04,030000 --> 00:43:13,010000
вы можете переполнить до бесконечности или уменьшить до нуля, переполнить до бесконечности или минус бесконечности, в зависимости от знака.

431
00:43:20,030000 --> 00:43:32,680000
но тогда возникает вопрос: многие люди, занимающиеся машинным обучением, говорят, что на самом деле они даже не хотят, чтобы числа переполнялись до бесконечности, потому что они хотят использовать то, что у них есть. называйте это арифметикой насыщения, потому что в противном случае они будут

432
00:43:32,680000 --> 00:43:39,730000
смотри на множество бесконечностей, используя всего восемь битов, потому что это приведет к переполнению.

433
00:43:40,270000 --> 00:43:49,450000
это интересно, потому что дискуссия о том, сколько битов должно быть, возвращает тебя к дискуссиям 1940-х годов.

434
00:43:49,510000 --> 00:43:57,050000
в 1940-х годах фон Нейман, который тогда был крупным игроком, не хотел даже иметь экспоненциальные поля.

435
00:43:57,070000 --> 00:44:03,170000
он думал, что значимых полей достаточно, а о показательных полях может позаботиться программист.

436
00:44:03,670000 --> 00:44:09,660000
как мы видим, в 1940-х годах компьютеры стоили очень дорого.

437
00:44:09,660000 --> 00:44:11,490000
у вас было очень мало битов.

438
00:44:12,390000 --> 00:44:25,730000
и он, по сути, хотел, чтобы программист делал все, что они хотят, ну, вы понимаете, чтобы не передавать на аутсорсинг вычисления, которые программист действительно мог бы выполнять.

439
00:44:26,070000 --> 00:44:28,970000
но теперь мы возвращаемся к тем же дискуссиям с

440
00:44:30,310000 --> 00:44:43,560000
с машинным обучением, потому что, если вы посмотрите на некоторые из этих статей по машинному обучению, в них говорится: "Ну, чтобы избежать переполнения, нам нужно выполнить масштабирование, нам нужно правильно масштабировать числа, что в принципе значит, этот программист"

441
00:44:43,560000 --> 00:44:49,130000
я хочу сказать, что, прежде чем приступить к вычислениям, нам следует умножить все на два, чтобы получить то или иное значение.

442
00:44:50,510000 --> 00:44:52,400000
нужно постараться избежать переполнения или недопотока.

443
00:44:52,400000 --> 00:44:58,370000
это действительно сложно, но, судя по тому, что я вижу в литературе по машинному обучению, это то, чем занимаются люди..

444
00:44:58,790000 --> 00:45:13,890000
с помощью арифметики насыщения им не придется беспокоиться о том, что данные будут переполняться до бесконечности, но проблема с арифметикой насыщения заключается в следующем: предположим, вы продолжайте удваивать и

445
00:45:14,510000 --> 00:45:22,770000
у вас есть очень большое число, и вы умножаете его само на себя, и вы просто получите то же самое число обратно опять же, потому что у вас уже есть самое большое число.

446
00:45:22,830000 --> 00:45:25,040000
с IEEE это число могло бы достигать бесконечности.

447
00:45:25,040000 --> 00:45:29,960000
а потом, если еще раз разделить его на это большое число, все равно получится бесконечность.

448
00:45:29,960000 --> 00:45:30,930000
так что вы действительно будете знать.

449
00:45:31,910000 --> 00:45:39,210000
но если у тебя будет очень большое число, а потом вы снова начинаете уменьшать его, то никогда не узнаешь, насколько оно было большим.

450
00:45:40,670000 --> 00:45:44,490000
вы действительно потеряли не только точность, но и масштабирование.

451
00:45:45,190000 --> 00:45:49,210000
и опять же, это кажется немного пугающим.

452
00:45:50,030000 --> 00:45:57,960000
конечно, еще одна большая проблема заключается в том, что машинное обучение больше не используется только для того, чтобы отличать кошек от собак.

453
00:45:57,960000 --> 00:45:59,480000
я имею в виду, что это стереотип, верно?

454
00:45:59,480000 --> 00:46:00,850000
оно используется для всего.

455
00:46:01,350000 --> 00:46:08,970000
и поэтому существует большой риск в том, чтобы делать это недостаточно точно.

456
00:46:10,590000 --> 00:46:13,530000
так что очень трудно представить, как все это будет происходить.

457
00:46:13,550000 --> 00:46:19,850000
а что касается P3109, то я уверен, что в конечном итоге мы получим отчет об этом.

458
00:46:19,870000 --> 00:46:25,930000
но я не знаю, продвинется ли индустрия уже настолько далеко, что это перестанет их интересовать.

459
00:46:26,950000 --> 00:46:29,560000
или, может быть, это будет соответствовать тому, что делает индустрия.

460
00:46:29,560000 --> 00:46:30,410000
трудно сказать наверняка.

461
00:46:30,630000 --> 00:46:43,460000
еще одна вещь, которая происходит, заключается в том, что 754, оригинальный стандарт с плавающей запятой, уже готовится к следующей редакции, потому что это было в 1985 и 2008 годах с опозданием, а затем в 2019 году с опозданием.

462
00:46:43,460000 --> 00:46:48,280000
так что следующий фильм должен выйти в 2029 году, а это, знаешь ли, пугающе близко.

463
00:46:48,280000 --> 00:46:49,570000
до него осталось всего пять лет.

464
00:46:50,230000 --> 00:46:58,090000
и этот стандарт с плавающей запятой - очень сложный документ, и многое меняется с точки зрения деталей аппаратного обеспечения и прочего.

465
00:46:59,150000 --> 00:47:02,570000
так что я тоже присоединился к обсуждениям.

466
00:47:03,470000 --> 00:47:12,770000
весь комитет 3109 был приглашен присоединиться к обсуждению создания новой рабочей группы 754 2029 года.

467
00:47:12,870000 --> 00:47:16,450000
ее возглавляет парень по имени Леонард Цай, который очень активен.

468
00:47:18,390000 --> 00:47:22,050000
и этот комитет будет создан очень скоро.

469
00:47:22,830000 --> 00:47:27,370000
рабочая группа, я говорю "комитет", но по терминологии IEEE это рабочая группа.

470
00:47:28,510000 --> 00:47:42,210000
Группы - это технические комитеты, которые, по сути, дают все эти технические рекомендации по самым разным вопросам IEEE, ну, вы знаете, механизм утверждения, что бы это ни было, правление или что-то еще.

471
00:47:43,710000 --> 00:47:52,570000
у меня есть еще один, последний вопрос, но я думаю, что он очень важный, так что не стесняйтесь отвечать так коротко или так долго, как вам хочется.

472
00:47:52,870000 --> 00:47:56,290000
я думаю, что на самом деле мы не обсуждали никаких процессоров.

473
00:47:56,790000 --> 00:48:03,770000
как вы думаете, какие-либо современные архитектуры лучше других с точки зрения вычислений с плавающей запятой?

474
00:48:03,830000 --> 00:48:08,730000
или, может быть, существуют какие-то особые инструкции или специальные архитектурные решения?

475
00:48:10,990000 --> 00:48:12,040000
да, я с тобой согласен.

476
00:48:12,040000 --> 00:48:12,700000
это большой вопрос.

477
00:48:12,700000 --> 00:48:16,010000
на самом деле я не тот человек, которого нужно спрашивать, потому что я не специалист по аппаратному обеспечению.

478
00:48:16,950000 --> 00:48:21,410000
но я имею в виду, что в целом чипы Intel были очень высокого качества.

479
00:48:22,830000 --> 00:48:29,530000
они были очень последовательны в принятии стандарта.

480
00:48:31,950000 --> 00:48:40,680000
если вы посмотрите на Mac, посмотрите на компьютеры Macintosh, как они раньше назывались, раньше они использовали чипы Motorola, а теперь перешли на чипы Intel.

481
00:48:40,680000 --> 00:48:44,400000
теперь у них есть свои собственные чипы, система Apple на чипе.

482
00:48:44,400000 --> 00:48:46,860000
это M1, M2, M3.

483
00:48:46,860000 --> 00:48:49,090000
я думаю, что это M4.

484
00:48:49,350000 --> 00:48:51,090000
они уже записали M4, да.

485
00:48:52,350000 --> 00:48:56,210000
так что, по-моему, эти чипсы тоже очень хороши.

486
00:48:56,390000 --> 00:48:59,730000
они очень тщательно подходят к правильному внедрению стандарта.

487
00:49:01,990000 --> 00:49:06,890000
на самом деле, есть интересная история, которую мы могли бы рассказать об ошибке в Pentium, но позвольте мне вернуться к ней.

488
00:49:08,510000 --> 00:49:16,130000
NVIDIA NVIDIA стала крупным игроком в этом бизнесе благодаря играм, верно, благодаря графическим процессорам.

489
00:49:16,750000 --> 00:49:19,820000
а оригинальные графические процессоры не соответствовали стандарту IEEE.

490
00:49:19,820000 --> 00:49:22,040000
но потом они действительно перешли на CUDA.

491
00:49:22,040000 --> 00:49:24,730000
они действительно начали делать вещи, совместимые с IEEE.

492
00:49:24,990000 --> 00:49:40,370000
я думаю, что у них нет, я полагаю, что они не включают флаги исключений по причинам, на которые я как бы намекал ранее, потому что это не так удобно с многопоточностью и прочим, и весь этот параллелизм.

493
00:49:42,630000 --> 00:49:45,530000
но в большинстве случаев они соответствуют стандарту IEEE.

494
00:49:49,750000 --> 00:49:55,080000
да, насчет чипов Google я не уверен, потому что они поддерживают bfloat 16.

495
00:49:55,080000 --> 00:49:58,160000
но, насколько я знаю, у них даже нет постепенного снижения расхода.

496
00:49:58,160000 --> 00:49:59,080000
возможно, я ошибаюсь на этот счет.

497
00:49:59,080000 --> 00:50:01,740000
я не думаю, что они заявляли, есть ли у них это или нет.

498
00:50:01,740000 --> 00:50:04,000000
я поговорил с одним сотрудником Google, который был очень полезен.

499
00:50:04,000000 --> 00:50:06,250000
но он сказал, что есть некоторые вещи, о которых он не может мне рассказать.

500
00:50:09,190000 --> 00:50:13,580000
и если вы хотите услышать историю с ошибкой в Pentium, то это еще одна история.

501
00:50:13,580000 --> 00:50:15,080000
да, я должен быть там.

502
00:50:15,080000 --> 00:50:16,210000
ты, наверное, знаешь об этом, да.

503
00:50:17,430000 --> 00:50:21,210000
так вот, как я уже сказал, Intel создала все эти замечательные чипы.

504
00:50:21,590000 --> 00:50:27,010000
тогда, в 1994 году, Pentium, я думаю, был чем-то вроде новинки.

505
00:50:29,910000 --> 00:50:34,690000
и с тех пор Pentium претерпел множество изменений.

506
00:50:35,430000 --> 00:50:37,740000
он стал фирменным знаком Intel.

507
00:50:37,740000 --> 00:50:39,700000
так что существует много-много различных типов Pentium.

508
00:50:39,700000 --> 00:50:43,210000
но в 1994 году ... О на дисплее твой кот!

509
00:50:43,470000 --> 00:50:48,450000
о, он тоже интересуется плавающими точками.

510
00:50:49,870000 --> 00:50:56,920000
так вот, в 1994 году жил парень по имени Найсли, Томас Найсли, кажется, он жил в Вирджинии.

511
00:50:56,920000 --> 00:51:01,290000
он был математиком и проводил эксперименты с теорией чисел.

512
00:51:01,430000 --> 00:51:06,780000
он проводил множество вычислений и в конце концов понял, что некоторые из них неверны.

513
00:51:06,780000 --> 00:51:10,770000
так что, на самом деле, я даже не рассказал тебе о самом важном в стандарте.

514
00:51:10,910000 --> 00:51:12,330000
может быть, мне стоит сначала рассказать тебе об этом.

515
00:51:12,670000 --> 00:51:23,900000
итак, на самом деле в стандарте говорится, что помимо всего этого, вы знаете, такие детали, как бесконечности и детали представления.

516
00:51:23,900000 --> 00:51:35,140000
самая важная вещь, которую устанавливает стандарт, заключается в том, что при сложении двух чисел с плавающей запятой результатом должно быть правильно округленное значение истинного результата.

517
00:51:35,140000 --> 00:51:39,250000
это означает, что оно максимально точное, учитывая представление.

518
00:51:39,350000 --> 00:51:41,850000
то же самое происходит с умножением, делением и так далее.

519
00:51:42,110000 --> 00:51:46,000000
раньше все было так же, как в старых суперкомпьютерах Cray, они бы не стали утруждать себя этим.

520
00:51:46,000000 --> 00:51:47,560000
они сказали: "Ну что ж, мы просто хотим быть быстрыми".

521
00:51:47,560000 --> 00:51:50,530000
и если что-то не совсем правильно, иногда это действительно не имеет значения.

522
00:51:50,670000 --> 00:52:06,220000
ну, знаешь, именно такое отношение в первую очередь побудило комитет IEEE 754 заявить: "Нет, вычисления должны быть точными".

523
00:52:06,220000 --> 00:52:09,240000
мне следовало сказать об этом раньше, потому что это действительно очень важный момент.

524
00:52:09,240000 --> 00:52:11,090000
но, в любом случае, было бы неплохо приберечь это на конец, может быть.

525
00:52:12,230000 --> 00:52:27,260000
ну что ж, это означает, что в двойном формате, 64 бита, значения должны быть точными, я думаю, это 53 бита, значения или мантиссы, потому что

526
00:52:27,260000 --> 00:52:30,930000
у тебя также есть куча битов для показателя степени, 11 бит для показателя степени.

527
00:52:31,030000 --> 00:52:40,170000
так что они должны быть с точностью до 53 бит в значении, включая скрытый бит, который переводится в десятичную систему счисления, если вы можете как-то вычислить перевод.

528
00:52:40,910000 --> 00:52:50,730000
так что преобразуй 10 из 2 в 53, что является числом.

529
00:52:51,230000 --> 00:52:52,770000
так что же это такое?

530
00:52:53,270000 --> 00:52:56,130000
это примерно 16.

531
00:52:56,790000 --> 00:53:01,810000
другими словами, от 2 до 53 получается примерно 10 к 16.

532
00:53:02,190000 --> 00:53:04,850000
это всего лишь небольшой математический факт.

533
00:53:06,150000 --> 00:53:08,020000
а почему мы вообще используем десятичную базу?

534
00:53:08,020000 --> 00:53:09,300000
это еще одна интересная вещь, не так ли?

535
00:53:09,300000 --> 00:53:11,290000
но ведь это из-за этого, не так ли?

536
00:53:13,390000 --> 00:53:18,460000
у нас по 10 пальцев на руках и ногах, так что им тысячи лет.

537
00:53:18,460000 --> 00:53:20,890000
люди, вы видите эти 10 пальцев.

538
00:53:21,550000 --> 00:53:23,250000
идея исчисления десятками - это идея.

539
00:53:24,950000 --> 00:53:27,780000
у меня в книге тоже есть кое-что по истории, если вам интересно больше.

540
00:53:27,780000 --> 00:53:35,930000
в любом случае, как я уже сказал, двоичный код - это то, что нужно использовать в компьютерах, и эта идея была принята еще в 1940-х годах.

541
00:53:38,110000 --> 00:53:42,960000
но если что-то имеет точность до 53 бит, то до скольких десятичных разрядов это точно?

542
00:53:42,960000 --> 00:53:46,010000
ну что ж, ответ примерно равен 16, и вот в чем причина.

543
00:53:46,870000 --> 00:53:57,090000
так вот, я обнаружил, что его цифры, которые должны были быть точными примерно до 16 цифр, были точны только до четырех цифр в некоторых очень необычных случаях.

544
00:53:57,750000 --> 00:53:59,450000
и он подумал: "Ну что ж, это странно".

545
00:53:59,630000 --> 00:54:01,290000
так он связался с Intel.

546
00:54:01,990000 --> 00:54:08,610000
и оказалось, что Intel действительно знала об этом, но они никому не говорили, потому что думали, что никто не заметит.

547
00:54:10,710000 --> 00:54:14,800000
а потом это стало сенсацией в средствах массовой информации.

548
00:54:14,800000 --> 00:54:18,010000
но всегда есть один парень.

549
00:54:19,750000 --> 00:54:20,730000
вот именно.

550
00:54:20,910000 --> 00:54:32,210000
и это было действительно потрясающе, потому что если бы вы попытались убедить общественность с помощью рекламной кампании, что действительно важно иметь 16 десятичных цифр, люди просто начали бы зевать.

551
00:54:34,030000 --> 00:54:40,410000
но как только ты говоришь им, что они не могут этого получить, они внезапно просыпаются и говорят: "Нет, они нам нужны".

552
00:54:41,030000 --> 00:54:42,360000
именно так и сказали в Intel.

553
00:54:42,360000 --> 00:54:43,500000
они сказали, что все в порядке.

554
00:54:43,500000 --> 00:54:44,520000
на самом деле это никому не нужно.

555
00:54:44,520000 --> 00:54:45,860000
И мы починим твой компьютер.

556
00:54:45,860000 --> 00:54:47,320000
мы починим компьютеры ученых.

557
00:54:47,320000 --> 00:54:51,780000
но обычный человек, пользующийся компьютером, в этом не нуждается.

558
00:54:51,780000 --> 00:54:53,040000
в этом действительно нет необходимости.

559
00:54:53,040000 --> 00:54:54,570000
и тогда люди пришли в ярость.

560
00:54:54,870000 --> 00:54:56,260000
нет, мы этого хотим.

561
00:54:56,260000 --> 00:55:02,930000
и вот, в конце концов, Intel пришлось пойти на попятную и заменить все эти чипы Pentium, что, конечно же, обошлось им в кучу денег.

562
00:55:03,510000 --> 00:55:06,340000
и это вызвало очень негативную реакцию прессы.

563
00:55:06,340000 --> 00:55:13,880000
но, в конце концов, я думаю, это было действительно хорошо для всех, потому что теперь люди понимают, что нужно быть очень осторожным в таких вещах.

564
00:55:13,880000 --> 00:55:20,010000
сейчас гораздо больше внимания уделяется доказательству правильности аппаратных реализаций и тому подобным вещам.

565
00:55:21,070000 --> 00:55:23,330000
и никаких повторений по этому поводу не было.

566
00:55:24,470000 --> 00:55:38,180000
и это было так иронично, потому что Intel сделала больше, чем любая другая компания в истории, для того, чтобы донести точную информацию с плавающей запятой до широких масс, до людей в целом. не ученые и не инженеры.

567
00:55:38,180000 --> 00:55:42,930000
и совершенно неожиданно они получили негативную оценку в прессе.

568
00:55:43,230000 --> 00:55:51,320000
но, как бы то ни было, это вернулось, и теперь в течение многих лет на этих ноутбуках было написано "Intel inside", верно?

569
00:55:51,320000 --> 00:55:55,020000
и мы очень ценим то, что чипы Intel очень хороши.

570
00:55:55,020000 --> 00:56:10,400000
если вы посмотрите на топ-500, я не смог найти ничего более свежего, чем то, что должно быть даже за этот и прошлый год, но есть страница Википедии, посвященная топ-500 ПК, процессорам из Август

571
00:56:10,400000 --> 00:56:11,760000
сейчас 2022 год, а это уже очень давно.

572
00:56:11,760000 --> 00:56:12,610000
все основано на неудачах.

573
00:56:13,590000 --> 00:56:16,410000
да, это самые быстрые компьютеры.

574
00:56:17,350000 --> 00:56:21,170000
конечно же, все это массивно-параллельные процессоры.

575
00:56:24,270000 --> 00:56:31,860000
в 2022 году, я думаю, 380 из 500 компьютеров были Intel, или, по крайней мере, они были x86.

576
00:56:31,860000 --> 00:56:33,920000
нет, я думаю, что почти все они были x86.

577
00:56:33,920000 --> 00:56:35,090000
я должен был бы проверить.

578
00:56:35,190000 --> 00:56:37,050000
и большинство из них - это данные Intel.

579
00:56:37,990000 --> 00:56:40,940000
единственная компания, о которой я не упомянул, - это AMD.

580
00:56:40,940000 --> 00:56:42,040000
я знал, что есть еще одна.

581
00:56:42,040000 --> 00:56:42,860000
я совсем забыл.

582
00:56:42,860000 --> 00:56:56,650000
AMD производит практически те же чипы, что и Intel, потому что они заключили сделку с Intel еще в 80-х годах, когда IBM приняла Intel на вооружение.

583
00:56:56,830000 --> 00:56:59,210000
это еще одна супер ироничная история, не так ли?

584
00:56:59,670000 --> 00:57:06,250000
IBM взяла на вооружение технологию Intel для производства своих ПК, потому что они не думали об этом, чтобы сделать чип для своего ПК.

585
00:57:06,350000 --> 00:57:10,410000
в те дни они не думали, что ноутбуки станут серьезным бизнесом.

586
00:57:10,470000 --> 00:57:15,760000
у них был свой крупный бизнес по производству мэйнфреймов, в котором IBM, крупные компании, Intel - это всего лишь маленький стартап.

587
00:57:15,760000 --> 00:57:18,330000
конечно, сейчас Intel - гораздо более крупная компания.

588
00:57:19,550000 --> 00:57:30,530000
а также, конечно, еще одним мелким игроком в то время были Билл Гейтс и Microsoft, и они заключили сделку с Intel, и потом, конечно, Microsoft тоже стала намного крупнее IBM.

589
00:57:31,190000 --> 00:57:33,760000
так что все это очень иронично, не так ли?

590
00:57:33,760000 --> 00:57:45,650000
ну что ж, причина, по которой AMD пришлось создавать те же разработки, что и Intel, заключалась в том, что IBM сказала: "Послушай, мы не собираемся просто так зацикливаться на этой маленькой компании Intel".

591
00:57:45,670000 --> 00:57:47,200000
а что, если Intel обанкротится?

592
00:57:47,200000 --> 00:57:48,400000
нам нужна поддержка?

593
00:57:48,400000 --> 00:57:50,380000
поэтому они настояли на создании второй компании.

594
00:57:50,380000 --> 00:57:56,170000
все это описано в книге под названием, кажется, она так и называется, я забыл.

595
00:57:56,790000 --> 00:57:57,890000
я мог бы поискать это в интернете.

596
00:57:57,990000 --> 00:57:59,650000
это будет во втором издании.

597
00:58:02,230000 --> 00:58:03,410000
это не моя книга.

598
00:58:03,550000 --> 00:58:10,570000
я имею в виду, что книга, описывающая эти решения IBM, уже опубликована.

599
00:58:11,190000 --> 00:58:18,560000
так или иначе, они настояли на том, чтобы другая компания тоже могла продавать эти решения.

600
00:58:18,560000 --> 00:58:31,330000
ну, так что AMD долгое время была как бы второстепенной по отношению к Intel, но затем в начале 2000-х Intel действительно споткнулась со своим дизайном IA 64, или нет, IA 32, я думаю, так оно и было.

601
00:58:33,590000 --> 00:58:35,130000
я думаю, что это IA 32.

602
00:58:38,670000 --> 00:58:47,970000
дело в том, что на самом деле он не получил широкого распространения, и AMD выпустила что-то, что они назвали, по-моему, X 64 или что-то в этом роде.

603
00:58:48,390000 --> 00:58:51,380000
я имею в виду x86, наверное.

604
00:58:51,380000 --> 00:58:51,840000
да.

605
00:58:51,840000 --> 00:58:56,330000
потому что все эти чипы Intel стали известны как x86.

606
00:58:56,390000 --> 00:59:08,610000
изначально число с плавающей запятой было x 87, 8087, а затем 87 было преобразовано в x86. и Pentium является частью последовательности x86.

607
00:59:09,670000 --> 00:59:22,290000
а затем AMD создала эти x86, и они перешли на 64-разрядный процессор, который относится к, а не к с плавающей запятой, но с учетом того, как организована память с 64 битами.

608
00:59:22,430000 --> 00:59:31,290000
а потом дизайн AMD x86 получил широкое распространение, и даже Intel в конце концов перешла на него.

609
00:59:31,790000 --> 00:59:34,650000
я думаю, что это довольно пространный ответ на твой вопрос.

610
00:59:34,910000 --> 00:59:40,890000
да, но, как всегда, я многому научился, так что большое спасибо.

611
00:59:40,950000 --> 00:59:48,130000
я думаю, нам пора заканчивать, потому что сейчас уже почти час, а может быть, даже больше.

612
00:59:48,990000 --> 00:59:51,090000
да, большое спасибо.

613
00:59:51,350000 --> 00:59:53,250000
я действительно многому научился.

614
00:59:54,630000 --> 00:59:56,020000
я здорово посмеялся.

615
00:59:56,020000 --> 01:00:00,880000
и я думаю, что нашим зрителям это понравится так же, как и мне.

616
01:00:00,880000 --> 01:00:01,640000
это так здорово.

617
01:00:01,640000 --> 01:00:02,880000
я так рад это слышать.

618
01:00:02,880000 --> 01:00:05,530000
скоро выйдет второе издание.

619
01:00:05,950000 --> 01:00:10,140000
да, я добавлю в описание все ссылки, которые вы мне пришлете.

620
01:00:10,140000 --> 01:00:17,780000
и большое спасибо за то, что ответили на все мои вопросы, углубились в историю и технические аспекты.

621
01:00:17,780000 --> 01:00:19,050000
это действительно потрясающе.

622
01:00:19,790000 --> 01:00:21,210000
это было действительно приятно.
